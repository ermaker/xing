#!/usr/bin/env ruby

require 'bundler/setup'
require 'dotenv'
Dotenv.load
require 'xing'
require 'mshard'
require 'logger'

at_exit do
  require 'English'
  MShard::MShard.new.set_error($ERROR_INFO) if $ERROR_INFO
end

STDOUT.sync = true
LOGGER = Logger.new(STDOUT)

at_exit do
  require 'English'
  if $ERROR_INFO
    LOGGER.fatal { "#{$ERROR_INFO}" }
    LOGGER.fatal { "#{$ERROR_INFO.backtrace.join(' | ')}" }
  end
end

def continue?
  MShard::MShard.new.get(:notify) != 'stop'
end

def notify(contents)
  MShard::MShard.new.set_safe(pushbullet: true, type: :note, title: contents)
end

def log_if_multiple_messages(retval)
  return unless retval['response'].size > 1
  LOGGER.warn { "Multiple response: #{retval}" }
end

def t1901(shcode, delay: 5) # rubocop:disable Metrics/MethodLength
  loop do
    retval = Xing::API.tr(:t1901, shcode: shcode)
    begin
      log_if_multiple_messages(retval)
      price = retval['response'].last['price'].to_i
      return price unless price.zero?
      LOGGER.error { "Price is zero. retval: #{retval}" }
    rescue NoMethodError # rubocop:disable Lint/HandleExceptions
    end
    LOGGER.error { "Retry: #{retval['message'].join(', ')}" }
    sleep delay
  end
end

BOUGHT = 'bought'

def traded?(record_id)
  return false unless MShard::MShard.new.get(record_id) == BOUGHT
  # LOGGER.debug { 'Already traded.' }
  true
end

def trade_(shcode, sell_or_buy, qty)
  LOGGER.debug { 'Try trade.' }
  retval = Xing::API.tr(
    :CSPAT00600,
    pass: ENV['ACCOUNT_PASS'],
    shcode: shcode, qty: qty, sell_or_buy: sell_or_buy)
  LOGGER.debug { "retval: #{retval}" }
  LOGGER.info { "Trade message: #{retval['message'].join(', ')}" }
end

def write_traded(shcode, sell_or_buy, qty, record_id)
  MShard::MShard.new.set_safe(
    id: record_id, contents: BOUGHT,
    pushbullet: true, type: :note,
    title: "#{shcode}] #{sell_or_buy} #{qty} (#{record_id})"
  )
  LOGGER.debug { 'Finished trade.' }
end

def trade(shcode, sell_or_buy, qty, record_id)
  return unless yield
  # LOGGER.debug do
  #   "Satisfied: #{shcode}, #{sell_or_buy}, #{qty}, #{record_id}"
  # end
  return if traded?(record_id)
  trade_(shcode, sell_or_buy, qty)
  write_traded(shcode, sell_or_buy, qty, record_id)
end

def in_time?
  Time.now < Time.parse('2016-01-30 14:30:00 +0900') &&
    Time.parse('2016-01-30 08:30:00 +0900') < Time.now
end

SLEEP = 4

loop do
  if in_time?
    LOGGER.debug { 'in_time' }
    sleep SLEEP * 10
    redo
  end

  # if continue?
  #   begin
  #     leverage = t1901(:leverage)
  #     LOGGER.debug { "Leverage: #{leverage}" }

  #     # if leverage > 10_000
  #     #   notify("Leverage: #{leverage}")
  #     #   LOGGER.info { "Leverage: #{leverage}" }
  #     # end

  #     # base = 8920

  #     # base.step(base - 800, -10) do |price|
  #     #   trade(:leverage, :buy, 1, :"xing_test2_#{price}") do
  #     #     leverage < price
  #     #   end
  #     # end

  #     # base = 10250

  #     # base.step(base + 500, 10) do |price|
  #     #   trade(:leverage, :sell, 1, :"#{price}_lev_sell") do
  #     #     leverage > price
  #     #   end
  #     # end
  #   end
  # else
  #   LOGGER.debug { 'Stopped. Passing' }
  # end
  #
  # sleep SLEEP

  if continue?
    begin
      inverse = t1901(:inverse)
      LOGGER.debug { "Inverse: #{inverse}" }

      base = 8190

      base.step(base - 500, -5) do |price|
        trade(:inverse, :buy, 10, :"#{price}_inv_buy_11") do
          inverse < price
        end
      end

      base = 8200

      base.step(base + 500, 5) do |price|
        trade(:inverse, :sell, 10, :"#{price}_inv_sell_0") do
          inverse > price
        end
      end
    end
  else
    LOGGER.debug { 'Stopped. Passing' }
  end

  sleep SLEEP
end
