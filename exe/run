#!/usr/bin/env ruby

require 'dotenv'
Dotenv.load
require 'xing'
require 'mshard'
require 'time'
require 'logger'
require 'English'

STDOUT.sync = true
LOGGER = Logger.new(STDOUT)

at_exit do
  if error_info = $ERROR_INFO
    LOGGER.fatal { "#{error_info}" }
    LOGGER.fatal { "#{error_info.backtrace.join(' | ')}" }
    MShard::MShard.new.set_error(error_info)
  end
end

def continue?
  MShard::MShard.new.get(:notify) != 'stop'
end

def notify(contents)
  MShard::MShard.new.set_safe(pushbullet: true, type: :note, title: contents)
end

def notify_if_important(retval)
  return unless retval.key? 'message' && !retval['message'].empty?
  if [*%w(-4225 -4226 -10054), '   -2'].include?(retval['message'].last[/^\[(.*?)\]/, 1])
    notify("Check Retval: #{retval['message'].join(', ')}")
  end
end

def price_(retval)
  retval['response'].last['price'].to_i
end

def price?(retval)
  retval.key?('response') &&
    !retval['response'].empty? &&
    retval['response'].last.key?('price')
end

def reboot_if_need(retval)
  if retval.code != 200
    LOGGER.debug { 'Reboot' }
    Xing::API.reboot
    notify('Reboot')
    sleep 90
  end
end

def t1901(shcode, delay: 5) # rubocop:disable Metrics/MethodLength
  loop do
    retval = Xing::API.tr(:t1901, shcode: shcode)
    notify_if_important(retval)
    return price_(retval) if price?(retval) && !price_(retval).zero?
    if price?(retval) && price_(retval).zero?
      LOGGER.debug { 'Retry: Price is zero.' }
    end
    LOGGER.debug { "Retry: #{retval['message']&.join(', ') || retval}" }
    reboot_if_need(retval)
    sleep delay
  end
end

BOUGHT = 'bought'

def traded?(record_id)
  return false unless MShard::MShard.new.get(record_id) == BOUGHT
  true
end

def trade_(shcode, sell_or_buy, qty, record_id)
  LOGGER.debug { 'Try trade.' }
  retval = Xing::API.tr(
    :CSPAT00600,
    pass: ENV['ACCOUNT_PASS'],
    shcode: shcode, qty: qty, sell_or_buy: sell_or_buy)
  LOGGER.debug { "retval: #{retval}" }
  LOGGER.info { "Trade message: #{retval['message'].join(', ')} (#{record_id})" }
end

def write_traded(name, shcode, sell_or_buy, qty, record_id)
  MShard::MShard.new.set_safe(
    id: record_id, contents: BOUGHT,
    pushbullet: true, type: :note,
    title: "#{name}] #{sell_or_buy} #{qty} (#{record_id})"
  )
  LOGGER.debug { 'Finished trade.' }
end

def trade(name, shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  trade_(shcode, sell_or_buy, qty, record_id)
  write_traded(name, shcode, sell_or_buy, qty, record_id)
end

def in_time?
  Time.now < Time.parse('07:30:00 +0900') &&
    Time.parse('07:00:00 +0900') < Time.now
end

def relax
  return if Time.parse('08:30:00 +0900') < Time.now &&
    Time.now < Time.parse('16:00:00 +0900') &&
    !Time.now.getlocal('+09:00').to_date.saturday? &&
    !Time.now.getlocal('+09:00').to_date.sunday?
  LOGGER.debug { 'Relax' }
  sleep SLEEP * 50
end

def just_check(name, shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  write_traded(name, shcode, sell_or_buy, qty, record_id)
end

def check_(name, shcode, current_price, base, step, label)
  base.step(base - step * 100, -step * 1) do |price|
    just_check(name, shcode, :ground, nil, :"#{price}_#{name}_check_ground_#{label}") do
      current_price < price
    end
  end

  base.step(base + step * 100, step * 1) do |price|
    just_check(name, shcode, :top, nil, :"#{price}_#{name}_check_top_#{label}") do
      current_price > price
    end
  end
end

class SingleStock
  attr_reader :current_price

  def initialize(name, shcode)
    @name = name
    @shcode = shcode
  end

  def read_current_price
    @current_price = t1901(@shcode)
    LOGGER.debug { "#{@name.capitalize}: #{@current_price}" }
  end

  def check(base, step, label)
    check_(@name, @shcode, @current_price, base, step, label)
  end

  def buy(base, step, qty, label)
    base.step(base - step * 100, -step * 1) do |price|
      trade(@name, @shcode, :buy, qty, :"#{price}_#{@name}_buy_#{label}") do
        @current_price < price
      end
    end
  end

  def sell(base, step, qty, label)
    base.step(base + step * 100, step * 1) do |price|
      trade(@name, @shcode, :sell, qty, :"#{price}_#{@name}_sell_#{label}") do
        @current_price > price
      end
    end
  end
end

SLEEP = 4

# kakao = SingleStock.new('kakao', '035720')
lev = SingleStock.new('lev', :leverage)
inv = SingleStock.new('inv', :inverse)
china_h = SingleStock.new('h', '204450')
oil = SingleStock.new('oil', '500019')
gold = SingleStock.new('gold', '225130')
kosdaq = SingleStock.new('kosdaq', '233160')

loop do
  if in_time?
    LOGGER.debug { 'in_time' }
    sleep SLEEP * 10
    redo
  end

  relax

  # kakao.read_current_price
  # kakao.check(93200, 100, 5)
  # sleep SLEEP

  lev.read_current_price
  # lev.buy(10155, 5, 5, 2)
  # lev.sell(10600, 5, 2, 0)
  lev.check(10350, 5, 6)
  sleep SLEEP

  inv.read_current_price
  # inv.buy(8005, 5, 2, 0)
  # inv.sell(8240, 5, 5, 0)
  inv.check(7985, 5, 6)
  sleep SLEEP

  china_h.read_current_price
  china_h.check(5700, 5, 6)
  sleep SLEEP

  oil.read_current_price
  oil.check(14150, 50, 6)
  sleep SLEEP

  gold.read_current_price
  gold.check(14000, 50, 6)
  sleep SLEEP

  kosdaq.read_current_price
  kosdaq.check(10980, 5, 6)
  sleep SLEEP
end
