#!/usr/bin/env ruby

require 'dotenv'
Dotenv.load
require 'xing'
require 'mshard'
require 'time'
require 'logger'
require 'English'

STDOUT.sync = true
LOGGER = Logger.new(STDOUT)

at_exit do
  if error_info = $ERROR_INFO
    LOGGER.fatal { "#{error_info}" }
    LOGGER.fatal { "#{error_info.backtrace.join(' | ')}" }
    MShard::MShard.new.set_error(error_info)
  end
end

def continue?
  MShard::MShard.new.get(:notify) != 'stop'
end

def notify(contents)
  MShard::MShard.new.set_safe(pushbullet: true, type: :note, title: contents)
end

def t1901(shcode, delay: 5) # rubocop:disable Metrics/MethodLength
  loop do
    retval = Xing::API.tr(:t1901, shcode: shcode)
    begin
      price = retval['response'].last['price'].to_i
      return price unless price.zero?
      LOGGER.debug { "Price is zero. retval: #{retval}" }
    rescue NoMethodError
    end
    LOGGER.debug { "Retry: #{retval['message']&.join(' ,') || retval}" }
    sleep delay
  end
end

BOUGHT = 'bought'

def traded?(record_id)
  return false unless MShard::MShard.new.get(record_id) == BOUGHT
  true
end

def trade_(shcode, sell_or_buy, qty, record_id)
  LOGGER.debug { 'Try trade.' }
  retval = Xing::API.tr(
    :CSPAT00600,
    pass: ENV['ACCOUNT_PASS'],
    shcode: shcode, qty: qty, sell_or_buy: sell_or_buy)
  LOGGER.debug { "retval: #{retval}" }
  LOGGER.info { "Trade message: #{retval['message'].join(', ')} (#{record_id})" }
end

def write_traded(shcode, sell_or_buy, qty, record_id)
  MShard::MShard.new.set_safe(
    id: record_id, contents: BOUGHT,
    pushbullet: true, type: :note,
    title: "#{shcode}] #{sell_or_buy} #{qty} (#{record_id})"
  )
  LOGGER.debug { 'Finished trade.' }
end

def trade(shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  trade_(shcode, sell_or_buy, qty, record_id)
  write_traded(shcode, sell_or_buy, qty, record_id)
end

def in_time?
  Time.now < Time.parse('2016-01-30 14:30:00 +0900') &&
    Time.parse('2016-01-30 08:30:00 +0900') < Time.now
end

def just_check(shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  write_traded(shcode, sell_or_buy, qty, record_id)
end

def check_(name, shcode, current_price, base, step, label)
  base.step(base - step * 100, -step * 1) do |price|
    just_check(shcode, :ground, nil, :"#{price}_#{name}_check_ground_#{label}") do
      current_price < price
    end
  end

  base.step(base + step * 100, step * 1) do |price|
    just_check(shcode, :top, nil, :"#{price}_#{name}_check_top_#{label}") do
      current_price > price
    end
  end
end

class SingleStock
  attr_reader :current_price

  def initialize(name, shcode)
    @name = name
    @shcode = shcode
  end

  def read_current_price
    @current_price = t1901(@shcode)
    LOGGER.debug { "#{@name.capitalize}: #{@current_price}" }
  end

  def check(base, step, label)
    check_(@name, @shcode, @current_price, base, step, label)
  end

  def buy(base, step, qty, label)
    base.step(base - step * 100, -step * 1) do |price|
      trade(@shcode, :buy, qty, :"#{price}_#{@name}_buy_#{label}") do
        @current_price < price
      end
    end
  end

  def sell(base, step, qty, label)
    base.step(base + step * 100, step * 1) do |price|
      trade(@shcode, :sell, qty, :"#{price}_#{@name}_sell_#{label}") do
        @current_price > price
      end
    end
  end
end

SLEEP = 5

kakao = SingleStock.new('kakao', '035720')
lev = SingleStock.new('lev', :leverage)
inv = SingleStock.new('inv', :inverse)

loop do
  if in_time?
    LOGGER.debug { 'in_time' }
    sleep SLEEP * 10
    redo
  end

  kakao.read_current_price
  kakao.check(91200, 100, 0)
  sleep SLEEP

  lev.read_current_price
  # lev.buy(10400, 5, 2, 0)
  # lev.sell(10600, 5, 2, 0)
  lev.check(9740, 5, 0)
  sleep SLEEP

  inv.read_current_price
  # inv.buy(8005, 5, 2, 0)
  inv.sell(8240, 5, 5, 0)
  inv.check(8230, 5, 0)
  sleep SLEEP
end
