#!/usr/bin/env ruby

require 'dotenv'
Dotenv.load
require 'xing'
require 'mshard'
require 'time'
require 'logger'
require 'English'

STDOUT.sync = true
LOGGER = Logger.new(STDOUT)

at_exit do
  if error_info = $ERROR_INFO
    LOGGER.fatal { "#{error_info}" }
    LOGGER.fatal { "#{error_info.backtrace.join(' | ')}" }
    MShard::MShard.new.set_error(error_info)
  end
end

def continue?
  MShard::MShard.new.get(:notify) != 'stop'
end

def notify(contents)
  MShard::MShard.new.set_safe(pushbullet: true, type: :note, title: contents)
end

def log_if_multiple_messages(retval)
  return unless retval['response'].size > 1
  LOGGER.debug { "Multiple response: #{retval}" }
end

def t1901(shcode, delay: 5) # rubocop:disable Metrics/MethodLength
  loop do
    retval = Xing::API.tr(:t1901, shcode: shcode)
    begin
      log_if_multiple_messages(retval)
      price = retval['response'].last['price'].to_i
      return price unless price.zero?
      LOGGER.debug { "Price is zero. retval: #{retval}" }
    rescue NoMethodError
    end
    LOGGER.debug { "Retry: #{retval['message']&.join(' ,') || retval}" }
    sleep delay
  end
end

BOUGHT = 'bought'

def traded?(record_id)
  return false unless MShard::MShard.new.get(record_id) == BOUGHT
  true
end

def trade_(shcode, sell_or_buy, qty)
  LOGGER.debug { 'Try trade.' }
  retval = Xing::API.tr(
    :CSPAT00600,
    pass: ENV['ACCOUNT_PASS'],
    shcode: shcode, qty: qty, sell_or_buy: sell_or_buy)
  LOGGER.debug { "retval: #{retval}" }
  LOGGER.info { "Trade message: #{retval['message'].join(', ')}" }
end

def write_traded(shcode, sell_or_buy, qty, record_id)
  MShard::MShard.new.set_safe(
    id: record_id, contents: BOUGHT,
    pushbullet: true, type: :note,
    title: "#{shcode}] #{sell_or_buy} #{qty} (#{record_id})"
  )
  LOGGER.debug { 'Finished trade.' }
end

def trade(shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  trade_(shcode, sell_or_buy, qty)
  write_traded(shcode, sell_or_buy, qty, record_id)
end

def in_time?
  Time.now < Time.parse('2016-01-30 14:30:00 +0900') &&
    Time.parse('2016-01-30 08:30:00 +0900') < Time.now
end

def just_check(shcode, sell_or_buy, qty, record_id)
  return unless yield
  return if traded?(record_id)
  write_traded(shcode, sell_or_buy, qty, record_id)
end

def check_(name, shcode, base, step, label)

  current_price = t1901(shcode)
  LOGGER.debug { "#{name.capitalize}: #{current_price}" }

  base.step(base - step * 100, -step * 1) do |price|
    just_check(shcode, :ground, nil, :"#{price}_#{name}_check_ground_#{label}") do
      current_price < price
    end
  end

  base.step(base + step * 100, step * 1) do |price|
    just_check(shcode, :top, nil, :"#{price}_#{name}_check_top_#{label}") do
      current_price > price
    end
  end
end

SLEEP = 4

loop do
  if in_time?
    LOGGER.debug { 'in_time' }
    sleep SLEEP * 10
    redo
  end

  begin
    leverage = t1901(:leverage)
    LOGGER.debug { "Leverage: #{leverage}" }

    # base = 10200

    # base.step(base - 500, -5) do |price|
    #   trade(:leverage, :buy, 5, :"#{price}_lev_buy_2") do
    #     leverage < price
    #   end
    # end

    # base = 10500

    # base.step(base + 500, 5) do |price|
    #   trade(:leverage, :sell, 1, :"#{price}_lev_sell_2") do
    #     leverage > price
    #   end
    # end

    base = 10570

    base.step(base + 500, 5) do |price|
      just_check(:leverage, :sell, 1, :"#{price}_lev_check_0") do
        leverage > price
      end
    end
  end

  sleep SLEEP

  begin
    inverse = t1901(:inverse)
    LOGGER.debug { "Inverse: #{inverse}" }

    # base = 8035

    # base.step(base - 500, -5) do |price|
    #   trade(:inverse, :buy, 2, :"#{price}_inv_buy_14") do
    #     inverse < price
    #   end
    # end

    # base = 8035

    # base.step(base + 500, 5) do |price|
    #   trade(:inverse, :sell, 2, :"#{price}_inv_sell_14") do
    #     inverse > price
    #   end
    # end
  end

  sleep SLEEP

  check_('kakao', '035720', 96600, 100, 0)

  sleep SLEEP
end
